Tensorflow has a number of Python-only ops and we provide "immediate" version of them by using "drop-in replacement" property of our Immediate execution environment to create copies of those ops whose internal function calls go to "immediate.Environment" instead of original tensorflow namespace.

While wrapping "gen_.*_op" was straightforward, making Python-only ops is complex because those ops are less constrained. The hole is that over time, Python-only ops will get cleaned-up and exposed as native TensorFlow ops, in which case this part of TFImmediate can be deleted.

Until then, wrapping Python-only ops is important for adoption because they constitute the bulk of ops that are actually being used. Below is the list of most popular ops sorted by the number of users.

tf.constant  (Python-only)
tf.add 
tf.ones   (Python-only)
tf.random_uniform  (Python-only)
tf.concat    (Python-only)
tf.truncated_normal  (Python-only)
tf.reshape 
tf.reduce_sum    (Python-only)
tf.random_normal  (Python-only)
tf.nn.conv2d 
tf.nn.max_pool   (Python-only)


The design of Python wrapping reflects the following challenges:

-- Python-only ops can contain arbitrary Python code, which breaks the abstraction boundary and relies on implementation details. For instance "constant" in tensorflow/python/ops/constant_op.py" accesses underlying "Graph" directly and is hence incompatible. Another example is "Variable" which doesn't fit into our mode of reuse of ops. Therefore we must maintain a whitelist of allowed Python-only ops which are compatible with wrapping. Ops that are incompatible, but important will get manually implementation. For instance, "tf.constant" is by far the most popular TensorFlow function, so we must provide Immediate-compatible implementation or it.

-- Python-only ops can call other Python-only ops in the same module, they could call themselves, or they could call Python-only ops in other Python-op modules.For instance many functions in math_ops.py call Python-only ops in array_ops.py This requires picking correct order in which the wrapping is done, so that both function symbol and "__globals__" associated with it are pointing to correctly wrapped versions.

-- Python-only op modules use wildcard import from "gen_.*_op" module, and other kinds of imports which increase the number of symbols in that module that must be correctly handled.

For instance, array_ops.py has the following imports

from tensorflow.python.ops import gen_math_ops
from tensorflow.python.ops.constant_op import constant
from tensorflow.python.ops.gen_array_ops import *

When executing functions from this module, "gen_math_ops" is replaced with a version that wraps all generated Python ops and constant must be replaced with a manually crafted wrapper. To handle "*" import, we manually add rules for redirecting symbols form gen_array_ops to proper version that we discover during op whitelisting. Fortunately, referring to ops like <op> is rare, and most instances are referred to as gen_array_ops.<op>

-- We need to maintain separate version of "immediate" and "non-immediate" ops. For instance, tf.convert_n_to_tensor calls "tf.convert_to_tensor". To make the former function compatible with immediate execution we could update __globals__ of "tf.convert_n_to_tensor" so that calls to "convert_to_tensor" from inside "tf.convert_n_to_tensor" are handled by our immediate environment. In a naive implementation, there's only one function object corresponding to "convert_n_to_tensor" in the Python runtime, so this kind of update will affect things globally.

This is a problem because convert_n_to_tensor function is called from op_def_library which is called by tf.Immediate during graph construction, so we end up with a circular dependency.
